# SampleCPU

## 简单说明

1. 该CPU现在可以执行ori lui addiu beq这四种指令，但并没有完成数据相关，请自行添加相关数据通路。

2. 之后出现的问题可直接在群里提问，然后会被记录在这里形成Q&A。

3. 请使用github进行版本管理，便于验收时检查。至于使用organization还是直接在个人账号里生成repo可自行选择。

***

## 使用方法
    
1. 下载群文件中的nscscc2021_group_v0.01.7z到本地并解压，密码：nscscc2021

2. clone本项目到本地

3. 启动路径 nscscc2021_group_v0.01\func_test_v0.01\soc_sram_func\run_vivado\mycpu_prj1 下的 mycpu.xpr项目

4. 在vivado中添加源文件，把这个项目的.v文件都导入（包括lib文件夹下）。

5. 点击simulation进行仿真，第一次仿真时会对项目使用的ip核进行综合，可能需要等待10-25分钟不等（视电脑性能而定）。

6. 点击播放进行仿真，如果停止可在vivado下方的控制台看到提示信息，这是龙芯实验平台提供的比对机制会告诉你当前在哪条
       指令出现错误。

7. 运行的汇编指令可在 ~~nscscc2021_group_v0.01\func_test_v0.01\soft\memory_game\obj\test.s~~ D:\nscscc2020_group_v0.01\func_test_v0.01\soft\func\obj\test.s 该文件中查找，直接搜索PC值即可。（不好意思之前写错了）

8. 指令集文件可在doc文件夹的A03文件中查看。

9. 其他相关问题基本都可在doc文件夹中的文件中找到答案。
    
10. 欢迎留言，看到会回复，另外请注意Q&A的更新。

***

## 指令添加方法

1. 阅读 __A03__ 指令集文件，查看该指令会进行哪些操作

2. 对于IF段，新指令一般对其没有影（除了在添加异常的时候，需要检查指令地址是否出错）。

3. 对于ID段
    - 需要在该级进行指令分析
    - 从寄存器中读取需要的数据
    - 完成数据相关处理
    - 生成发给EX段和MEM段的控制信号。

4. 对于EX段
    - alu模块已经提供，基本通过给alu提供控制信号就可以完成逻辑和算术运算
    - load/store指令需要添加指令计算模块并控制data_sram_*信号组的输出，从而完成数据读写
    - branch/jump指令需要自己添加比较语句和判断逻辑并控制br_bus信号组，从而控制IF段正确完成跳转

5. 对于MEM段
    - 接收并处理访存的结果，并选择写回结果是ex_result还是mem_result。
    - ~~之后会在MEM段处理中断异常，不过暂时用不到~~

6. 对于WB段
    - 和ID段类似，暂时没有需要改动的东西

***

## debug建议

1. 查看console（控制台）中的trace比对机制的提示，记下提示的PC值，并猜测可能发生的错误。

2. 打开test.s文件，使用提示的PC值进行查找，查看该PC值对应的指令是什么，判断是否添加该指令。

3. 如果没添加指令，则前往 __A03__ 文件阅读指令集，学习对应指令如何添加。

4. 如果指令已经被添加，则到波形图中去检查运算结果错误原因。

5. 当找到错误波形图时，请逐步添加其源头信号，直至发现引入错误的源信号，并改正。

6. 修改后可能会出现新的错误，此时请重复步骤5。

7. 可能会遇到波形图并未自动停止的情况，已知有两种情况：测试程序因为错误执行陷入死循环，写回级的输出出现错误导致比对机制失效。

8. 如果不知道新的指令如何添加可以参考《自己动手做CPU》或者问助教。
    - PS：这本书原理说的还算明白，代码真别抄了，always写出来的组合逻辑你们把握不住。

9. 如果助教也不知道你们错在哪了，请陪他一块反思。

***

## 提示
    
如果有同学遇到访存指令的正确结果为0000aaaa，但是一直不对的时候请联系助教

***

## Q & A

1.  Q： 关于如何检查工作量？

    A： 建议各位同学每天写完代码都push到github上，到最后代码量一目了然，工作进度也很清楚。  
    （如果一定要最后几天扎堆提交，我也愿意听你解释，当然分数好不好看就不知道了）
    
2.  Q： 拿到这个模板我应该如何入手？
        
    A： 群里有《自己动手写CPU》这本书的PDF，如果对流水线、旁路、数据相关之类的内容还没有概念，可以先看看这本书。
    在掌握每章的内容后把该章节的内容写到自己的CPU里去。
    - PS：请不要妄图直接使用这本书里的源码，最后验收的时候会检查代码，两套代码长什么样我还是一清二楚的。
    - 对于别的学校的代码，如果你去观摩学习，然后把里面的好东西拿来用，那我非常支持。
    - 如果你直接把别人的代码copy过来用，那看一下代码风格，问几个问题基本就露馅了，没意思的。
    - 所以有问题就快问，别一直拖着。
    
3.  Q： 波形图左侧的列表里为什么和我选中的时刻的数值不一样啊？
        
    A： 波形图左侧列表里显示的数值是波形图运行到的最后一个时刻的数值，并不是鼠标点击时刻的数值。
    
    - 查看波形图时，先把需要的信号添加到波形图中，然后用鼠标点选锁定信号，再用下一个/上一个上升沿的按钮进行移动。
    - （点选信号，然后用方向键也能控制，更多控制方法可自行尝试）
    
4.  Q： 模块间的接线是接在哪里？
        
    A： mycpu_core.v内有所有模块的实例化和对应的接线。
    
    tips：接线的时候记得设置位宽，不然线是1位宽度，剩下的都是X。
    
5.  Q： core和top分别是干什么用的，为什么要分成两个文件？
        
    A： core是用来写cpu里的数据通路的，对应《自己动手写CPU》书中的顶层模块。top和core之间是为了后面补充地址映射模块的。
    
    待更新
